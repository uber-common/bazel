// Copyright 2014 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.google.devtools.build.lib.actions.usage;

import com.google.devtools.build.lib.actions.*;
import com.google.devtools.build.lib.buildtool.BuildRequestOptions.ActionInputUsageTrackerMode;
import com.google.devtools.build.lib.vfs.Path;
import com.google.devtools.build.lib.view.proto.Deps;

import javax.annotation.Nullable;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.*;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static com.google.common.base.Preconditions.checkState;
import static com.google.devtools.build.lib.actions.usage.Utils.getHashFromJarEntry;
import static com.google.devtools.build.lib.actions.usage.Utils.getJDepsOutput;

/**
 * Class responsible for removing irrelevant inputs used for an action cache key computation. The goal here is to
 * achieve incremental compilation avoidance by dismissing unused input. This way, any change to these input will
 * cause computed action cache key to remain unchanged, leading to a local cache hit / skip of action re-execution.
 * The list of unused input is generated by the action itself, during previous action execution, and stored to disk
 * among action outputs (typically .jdeps file for Java/Kotlin compilation action).
 * <p>
 * Action can also generate more granular usage data through used "classes". For these, changes not classes that are
 * not specified as 'used' will similarly be removed from action cache key computation.
 * <p>
 * Note of software design : instead of modifying Action/AbstractAction class itself (similarly to input discovery
 * feature), we use composition via this separate class to keep the logic separated, and facilitate merging changes
 * from Bazel master branch.
 */
public class ActionInputUsageTracker {

    /**
     * Internal class tracking usage info for a given action.
     */
    class UsageInfo {
        private Set<String> unusedArtifactPaths;
        private Map<String, Set<ClassUsageInfo>> usedClassesMap;
        private Set<String> usedResources;

        UsageInfo(Set<String> unusedArtifactPaths, Map<String, Set<ClassUsageInfo>> usedClassesMap, Set<String> usedResources) {
            this.unusedArtifactPaths = unusedArtifactPaths;
            this.usedClassesMap = usedClassesMap;
            this.usedResources = usedResources;
        }
    }

    private static final Set<String> SUPPORTED_DEPENDENCY_TRACKING_MNEMONICS = Set.of("Javac", "KotlinCompile", "KotlinKsp");
    private static final Set<String> SUPPORTED_CLASS_TRACKING_MNEMONICS = Set.of("Javac", "KotlinCompile", "KotlinKsp");
    private static final boolean VERBOSE_MODE = false;

    private final ArtifactPathResolver pathResolver;
    private final ActionInputUsageTrackerMode trackerMode;
    private final Map<String, UsageInfo> trackerInfoMap;

    public ActionInputUsageTracker(ArtifactPathResolver pathResolver, ActionInputUsageTrackerMode trackerMode) {
        this.pathResolver = pathResolver;
        this.trackerMode = trackerMode;
        this.trackerInfoMap = new ConcurrentHashMap<>();
    }

    /**
     * Whether action input tracking is enabled or not.
     */
    public boolean enabled() {
        return this.trackerMode != ActionInputUsageTrackerMode.DISABLED;
    }

    /**
     * Whether action supports input tracking.
     */
    public boolean supportsInputTracking(Action action) {
        return enabled() &&
                action.getOwner().getLabel() != null &&
                action.getOwner().getLabel().getRepository().isMain() &&
                (getJDepsOutput(action) != null || isKspAction(action)) &&
                SUPPORTED_DEPENDENCY_TRACKING_MNEMONICS.contains(action.getMnemonic());
    }

    /**
     * Whether action supports classes input tracking.
     */
    public boolean supportsClassTracking(Action action) {
        return (this.trackerMode == ActionInputUsageTrackerMode.UNUSED_CLASSES || this.trackerMode == ActionInputUsageTrackerMode.UNUSED_CLASSES_AND_RESOURCES) &&
                action.getOwner().getLabel() != null &&
                action.getOwner().getLabel().getRepository().isMain() &&
                (getJDepsOutput(action) != null || isKspAction(action)) &&
                SUPPORTED_CLASS_TRACKING_MNEMONICS.contains(action.getMnemonic());
    }

    /**
     * Whether action supports resources input tracking.
     */
    public boolean supportsResourceTracking(Action action) {
        return (this.trackerMode == ActionInputUsageTrackerMode.UNUSED_RESOURCES || this.trackerMode == ActionInputUsageTrackerMode.UNUSED_CLASSES_AND_RESOURCES) &&
                action.getOwner().getLabel() != null &&
                action.getOwner().getLabel().getRepository().isMain() &&
                (getJDepsOutput(action) != null || isKspAction(action)) &&
                SUPPORTED_CLASS_TRACKING_MNEMONICS.contains(action.getMnemonic());
    }

    /**
     * Refresh internal input tracking info from action .jdeps file.
     */
    public void refreshInputTrackingInfo(Action action) {
        if (!enabled() || !supportsInputTracking(action) || isKspAction(action)) {
            return;
        }

        try {
            Artifact jdeps = getJDepsOutput(action);
            Path output = pathResolver.toPath(jdeps);
            InputStream input = output.getInputStream();
            Deps.Dependencies deps = Deps.Dependencies.parseFrom(input);
            checkState(deps.getRuleLabel().equals(action.getOwner().getLabel().toString()));

            Set<String> usedPaths = deps.getDependencyList().stream()
                    .filter(d -> d.getKind() == Deps.Dependency.Kind.EXPLICIT || d.getKind() == Deps.Dependency.Kind.IMPLICIT)
                    .map(d -> d.getPath())
                    .collect(Collectors.toCollection(LinkedHashSet::new));
            Set<String> unusedArtifactsPath = action.getInputs().toList().stream()
                    .filter(ActionInputUsageTracker::canArtifactBeUnused)
                    .map(d -> d.getExecPathString())
                    .filter(Predicate.not(usedPaths::contains))
                    .collect(Collectors.toCollection(LinkedHashSet::new));
            Map<String, Set<ClassUsageInfo>> usedClassesMap = deps.getDependencyList().stream()
                    .filter(d -> d.getKind() == Deps.Dependency.Kind.EXPLICIT || d.getKind() == Deps.Dependency.Kind.IMPLICIT)
                    .collect(Collectors.toMap(
                            d -> d.getPath(),
                            d -> d.getUsedClassesList().stream()
                                    .map(ClassUsageInfo::create)
                                    .collect(Collectors.toCollection(LinkedHashSet::new))));
            Set<String> usedResources = deps.getUsedResourcesList().stream().collect(Collectors.toCollection(LinkedHashSet::new));

            UsageInfo usageInfo = new UsageInfo(unusedArtifactsPath, usedClassesMap, usedResources);
            trackerInfoMap.put(getKey(action), usageInfo);
        } catch (FileNotFoundException fileNotFoundException) {
            // Silently ignore, this could be a clean build
        } catch (Exception exception) {
            System.err.println("ActionInputUsageTracker: " + getKey(action) + " .jdeps file failed to load, ex=" + exception);
        }
    }

    /**
     * Get tracking information for the given action and input artifact. If includeDependencyHash is true, we include
     * in the return object classes hash computed from action dependencies themselves (as opposed to the hash of classes
     * that were used in the last action execution, which are always included).
     */
    public TrackingInfo getTrackingInfo(Action action, Artifact artifact, boolean includeDependencyHash) {
        boolean isUnused = supportsInputTracking(action) && isUnusedInput(action, artifact);

        Set<ClassUsageInfo> usedClasses = null;
        if (supportsClassTracking(action) && canArtifactTrackUsedClasses(artifact)) {
            UsageInfo usageInfo = getUsageInfo(action);
            if (usageInfo != null &&
                    usageInfo.usedClassesMap != null &&
                    usageInfo.usedClassesMap.getOrDefault(artifact.getExecPathString(), Collections.emptySet()).size() > 0) {
                usedClasses = usageInfo.usedClassesMap.get(artifact.getExecPathString());
                if (includeDependencyHash) {
                    usedClasses = usedClasses.stream()
                            .map(d -> ClassUsageInfo.create(
                                    d.getFullyQualifiedName(),
                                    d.getInternalPath(),
                                    d.getCompileTimeFileArtifactValue(),
                                    new PreComputedMetadataValue(getHashFromJarEntry(artifact, d.getInternalPath()))))
                            .collect(Collectors.toCollection(LinkedHashSet::new));
                }
            }
        }

        Set<String> usedResources = null;
        if (supportsResourceTracking(action) && canArtifactTrackUsedResources(action, artifact)) {
            UsageInfo usageInfo = getUsageInfo(action);
            if (usageInfo != null && usageInfo.usedResources != null) {
                usedResources = usageInfo.usedResources;
                if (includeDependencyHash) {
                    try {
                        Path output = pathResolver.toPath(artifact);
                        URL classUrl = new URL("file:" + output);
                        URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{classUrl});
                        usedResources = usedResources.stream()
                                .filter(resource -> resourceExists(artifact, resource, output, urlClassLoader))
                                .collect(Collectors.toCollection(LinkedHashSet::new));
                    } catch (Exception e) {
                        System.err.println("ActionInputUsageTracker: Failure computing res hash");
                        usedResources = null;
                    }
                }
            }
        }

        return new TrackingInfo(isUnused, usedClasses, usedResources);
    }

    /**
     * For debugging purpose.
     */
    public String dump(Action action) {
        int unusedCount = 0;
        int usedCount = 0;
        int usedClasses = 0;
        int usedResources = 0;
        StringBuilder s = new StringBuilder("ActionInputUsageTracker: " + getKey(action) + " ");
        for (Artifact input : action.getInputs().toList()) {
            if (!canArtifactBeUnused(input)) {
                continue;
            }
            boolean isUnused = supportsInputTracking(action) && isUnusedInput(action, input);
            TrackingInfo trackingInfo = getTrackingInfo(action, input, false);
            if (VERBOSE_MODE) {
                s.append("\n");
                if (isUnused) {
                    s.append("\t(-) " + input.getExecPathString() + "\n");
                } else {
                    s.append("\t(+) " + input.getExecPathString());
                    if (trackingInfo.tracksUsedClasses()) {
                        s.append(" (" + trackingInfo.getUsedClasses().size() + " tracked classes)");
                    }
                    if (trackingInfo.tracksUsedResources() && isLocalRArtifact(action, input)) {
                        s.append(" (" + trackingInfo.getUsedClasses().size() + " tracked resources)");
                    }
                }
            } else {
                if (isUnused) {
                    unusedCount++;
                } else {
                    usedCount++;
                    if (trackingInfo.tracksUsedClasses()) {
                        usedClasses += trackingInfo.getUsedClasses().size();
                    }
                    if (trackingInfo.tracksUsedResources() && isLocalRArtifact(action, input)) {
                        usedResources += trackingInfo.getUsedResources().size();
                    }
                }
            }
        }
        if (!VERBOSE_MODE) {
            String usedClassesStr = supportsClassTracking(action) ? String.format(", %d tracked classes", usedClasses) : "";
            String usedResourcesStr = supportsResourceTracking(action) ? String.format(", %d tracked resources", usedResources) : "";
            s.append(String.format("[%d used dep, %d unused dep%s%s]", usedCount, unusedCount, usedClassesStr, usedResourcesStr));
        }

        return s.toString();
    }

    /**
     * Returns the cache key used internally for a given action
     */
    private String getKey(Action action) {
        return action.getOwner().getLabel().toString() + "(" + action.getMnemonic() + ")";
    }

    /**
     * Returns whether input artifact is used by action or not.
     */
    private boolean isUnusedInput(Action action, Artifact input) {
        // Now that jdeps contains additional info (list of used classes/shas), we don't want these to contribute to
        // cache key, as this could cause undesired change of cache key.
        String artifactExecPath = input.getExecPathString();
        if (artifactExecPath.endsWith(".jdeps")) {
            return true;
        }

        if (!supportsInputTracking(action)) {
            return false;
        }

        // Filter out resources jar inputs from KSP action
        if (isKspAction(action) && isRArtifact(input)) {
            return true;
        }

        UsageInfo usageInfo = getUsageInfo(action);
        return usageInfo != null && usageInfo.unusedArtifactPaths.contains(artifactExecPath);
    }

    /**
     * Returns UsageInfo for the given action.
     */
    @Nullable
    private UsageInfo getUsageInfo(Action action) {
        return trackerInfoMap.getOrDefault(getKey(action), null);
    }

    /**
     * Returns whether input artifact can track classes or not.
     */
    private static boolean canArtifactTrackUsedClasses(Artifact artifact) {
        String artifactExecPath = artifact.getExecPathString();
        return artifactExecPath.endsWith("-ijar.jar") ||
                artifactExecPath.endsWith("-hjar.jar")  ||
                artifactExecPath.endsWith(".abi.jar") ||
                artifactExecPath.endsWith("_resources.jar");
    }

    /**
     * Returns whether input artifact can track resources or not.
     */
    private static boolean canArtifactTrackUsedResources(Action action, Artifact artifact) {
        String artifactExecPath = artifact.getExecPathString();
        return isLocalRArtifact(action, artifact);
    }

    /**
     * Returns whether artifact is eligible to be treated as unused. For java, our optimization is built
     * upon compiling against ABI jars, therefore we only support ijar/hjar/kotlin ABI.
     */
    private static boolean canArtifactBeUnused(Artifact artifact) {
        if (artifact.getRootRelativePathString().startsWith("external/") ||
                artifact.getExecPathString().startsWith("external/")) {
            return false;
        }

        String artifactExecPath = artifact.getExecPathString();
        return artifactExecPath.endsWith("-ijar.jar") ||
                artifactExecPath.endsWith("-hjar.jar") ||
                artifactExecPath.endsWith(".abi.jar") ||
                artifactExecPath.endsWith("_resources.jar");
    }

    private boolean isKspAction(Action action) {
        return "KotlinKsp".equals(action.getMnemonic());
    }

    private static boolean isRArtifact(Artifact artifact) {
        String artifactExecPath = artifact.getExecPathString();
        return artifactExecPath.endsWith("_resources.jar");
    }

    private static boolean isLocalRArtifact(Action action, Artifact artifact) {
        String artifactExecPath = artifact.getExecPathString().replace("/_migrated/", "/");
        String path = action.getOwner().getLabel().toString().replace("//", "/").replace("_kt", "").replace(":", "/");
        return isRArtifact(artifact) && artifactExecPath.indexOf(path) > 0;
    }

    public static void log(Action action, String msg) {
        if (isDebug(action)) {
            System.out.println("ActionCacheChecker: " + msg + " " + action.prettyPrint());
        }
    }
    public static boolean isDebug(Action action) {
        if (action.getOwner().getLabel() != null && action.getOwner().getLabel().toString().startsWith("//experimental/sample/simple/androidlib3:src_main")) {
            return true;
        }
        return false;
    }

    /**
     * Check wheter the provided resourceId is defined in the artifact.
     */
    private boolean resourceExists(Artifact artifact, String resId, Path localResourcesArtifact, URLClassLoader urlClassLoader) {
        if (!localResourcesArtifact.exists()) {
            // Missing file can happen due to BwoB. In this case, assume the resource is there.
            return true;
        }

        resId = resId.replace("com.uber.", "");
        if (resId.indexOf("R.") != 0) {
            if (resId.indexOf("android.R.") != 0) {
                System.err.println("WARN: Malformed res: " + resId);
            }
            return true;
        }

        try {
            String resourceName = resId.substring(resId.lastIndexOf('.') + 1);
            String resourceType = resId.substring(0, resId.lastIndexOf('.'));
            String resourceClassName = "com.uber." + resourceType.replace(".", "$");
            Class<?> resourceClass = urlClassLoader.loadClass(resourceClassName);
            Field f = resourceClass.getField(resourceName);
            return f != null;
        } catch (Exception e) {
            System.err.println("ActionInputUsageTracker: Lookup failed for " + resId + " in " + artifact.getExecPathString() + " : " + e);
        }
        return false;
    }
}
